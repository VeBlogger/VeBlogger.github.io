<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[初次使用JMeter……]]></title>
      <url>/2023/05/22/%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8JMeter%E2%80%A6%E2%80%A6/</url>
      <content type="html"><![CDATA[<h1 id="初次使用JMeter……"><a href="#初次使用JMeter……" class="headerlink" title="初次使用JMeter……"></a>初次使用JMeter……</h1><p>为了测试自己的接口在并发请求下表现如何，不得不快速入门了Apache JMeter。之前用过Postman，Postman的界面更友好美观，如果只是简单测试下接口的响应，强烈推荐Postman，但它确实并不支持并发测试。（至少我搜到的所谓postman并发测试教程都是错的，runner是阻塞排队执行，并不是并发。）</p>
<p>本文主要分为<strong>安装JDK、安装JMeter、JMeter的使用</strong>三大部分，其中JMeter的使用包括如下5个部分。全文操作下来仅需20min-1h，即可完成JMeter入门。</p>
<ul>
<li><p>添加线程组</p>
</li>
<li><p>添加HTTP请求</p>
</li>
<li><p>添加结果树视图&#x2F;聚合视图</p>
</li>
<li><p>执行性能测试&#x2F;并发测试</p>
</li>
<li><p>测试报告解读</p>
<span id="more"></span></li>
</ul>
<h2 id="Part-1-安装JDK"><a href="#Part-1-安装JDK" class="headerlink" title="Part 1. 安装JDK"></a>Part 1. 安装JDK</h2><p>由于JMeter是纯Java开发的软件，首先需要安装Java 8环境。</p>
<h3 id="1-1-JDK下载"><a href="#1-1-JDK下载" class="headerlink" title="1.1 JDK下载"></a><strong>1.1</strong> JDK<strong>下载</strong></h3><blockquote>
<p>推荐使用网盘下载，因为官网不知道何时起需要注册才能下载了。注册流程较为繁琐。</p>
<p>方法1：网盘下载：</p>
<p>链接：<a href="https://link.zhihu.com/?target=https://pan.baidu.com/s/1iVxsnX25mvbNia8-_bzIVg">https://pan.baidu.com/s/1iVxsnX25mvbNia8-_bzIVg</a></p>
<p>提取码：utnx</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/80/v2-479f11301ccaeb883171cc16bcbea064_720w.webp" alt="img"></p>
<p>方法2：官网下载：</p>
<p>官网地址：<a href="https://link.zhihu.com/?target=https://www.oracle.com/technetwork/java/javase/downloads/index.html">Java SE - Downloads</a>，下拉选择Download JDK。</p>
<p><img src="https://pic4.zhimg.com/80/v2-7ed749951a50276aaeb9b9d7dbe317df_720w.webp" alt="img"></p>
<p>在转跳的页面中，<strong>一定要先选择 Accept License Agreement</strong>接受许可要求，再选择对应版本，我的电脑系统为64位Windows，选择最后一个。最后在跳出的登录页面登陆成功后方可下载。</p>
<p><img src="https://pic2.zhimg.com/80/v2-1d7adcaaa8b11253f3c6dc6fac93e845_720w.webp" alt="img"></p>
<h3 id="1-2-JDK的安装"><a href="#1-2-JDK的安装" class="headerlink" title="1.2 JDK的安装"></a><strong>1.2 JDK的安装</strong></h3><p>安装没有什么问题，一路狂点”Next下一步”就好了。</p>
<h3 id="1-3-JDK的环境变量（可跳过）"><a href="#1-3-JDK的环境变量（可跳过）" class="headerlink" title="1.3 JDK的环境变量（可跳过）"></a>1.3 JDK的环境变量（可跳过）</h3><p>如果是默认方式安装一般会配置好环境变量，如果不放心可以自己查看下是否含有…….\Oracle\Java\javapath路径。</p>
<p><img src="https://pic3.zhimg.com/80/v2-7f1860a5f7e4cde708770c1aba6c453a_720w.webp" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-03e2603e37be289f456385efb4a6cd04_720w.webp" alt="img"></p>
<h2 id="Part-2-安装JMeter"><a href="#Part-2-安装JMeter" class="headerlink" title="Part 2. 安装JMeter"></a>Part 2. 安装JMeter</h2><h3 id="2-1-JMeter的下载"><a href="#2-1-JMeter的下载" class="headerlink" title="2.1 JMeter的下载"></a>2.1 JMeter的下载</h3><p>直接去官网下载最新版本的zip即可。</p>
<p>官网下载地址：<a href="https://link.zhihu.com/?target=http://jmeter.apache.org/download_jmeter.cgi">http://jmeter.apache.org/download_jmeter.cgi</a></p>
<p><img src="https://pic1.zhimg.com/80/v2-2fe8db017660e79429726a50f0be0f18_720w.webp" alt="img"></p>
<h3 id="2-2-JMeter的启动"><a href="#2-2-JMeter的启动" class="headerlink" title="2.2 JMeter的启动"></a>2.2 JMeter的启动</h3><p>将zip解压到你想要的位置。</p>
<p>进入解压后的bin目录，双击jmeter.bat文件即可启动。</p>
<p><img src="https://pic3.zhimg.com/80/v2-9306145ad6655ca9f00df050cc4e04da_720w.webp" alt="img"></p>
<p>会先打开一个cmd窗口，然后才是软件界面，如果关闭该cmd窗口软件也会关闭。</p>
<p><img src="https://pic4.zhimg.com/80/v2-aac3af18fbcc0d4583eca1f1e3d09947_720w.webp" alt="img"></p>
<h2 id="Part-3-JMeter的使用"><a href="#Part-3-JMeter的使用" class="headerlink" title="Part 3. JMeter的使用"></a>Part 3. JMeter的使用</h2><h3 id="3-1-切换为中文简体界面（可选）"><a href="#3-1-切换为中文简体界面（可选）" class="headerlink" title="3.1 切换为中文简体界面（可选）"></a>3.1 切换为中文简体界面（可选）</h3><p>Options-Choose Language-Chinese</p>
<p><img src="https://pic1.zhimg.com/80/v2-4a69151d7aab8974ad58d11515381dec_720w.webp" alt="img"></p>
<p>由于我这版本的中文界面字体太粗看着很难受，我还是以英文界面为例说明，同时附上中文翻译。</p>
<h3 id="3-2-添加线程组"><a href="#3-2-添加线程组" class="headerlink" title="3.2 添加线程组"></a>3.2 添加线程组</h3><p>右键点击“Test Plan测试计划”-“Add添加”-“Threads(Users)线程(用户)”-“Thread Group线程组”</p>
<p><img src="https://pic2.zhimg.com/80/v2-9a35a0338b66996c20854d2cb3ab99d5_720w.webp" alt="img"></p>
<p>这里可以配置线程组名称、线程数、循环次数、调度器等参数，如做2次20个并发的测试，将线程数改为20，循环数改为2即可。</p>
<p><img src="https://pic4.zhimg.com/80/v2-4aa544f0bf20b03bc2bd1d4f3302da63_720w.webp" alt="img"></p>
<h3 id="3-3-添加HTTP请求"><a href="#3-3-添加HTTP请求" class="headerlink" title="3.3 添加HTTP请求"></a>3.3 添加HTTP请求</h3><p>JMeter的功能其实很强大，但此处我们只对HTTP方法做测试。</p>
<p>右键点击“Thread Group线程组” - “Add添加”-“Sampler” - “HTTP Request”</p>
<p><img src="https://pic4.zhimg.com/80/v2-74cd954b6070253f01f4b2a08cabdf23_720w.webp" alt="img"></p>
<p>以172.12.123.183:9999&#x2F;test&#x2F;v1为例进行下图的参数填写。</p>
<p><strong>协议：</strong>向目标服务器发送HTTP请求协议，可以是HTTP或HTTPS，默认为HTTP</p>
<p><strong>服务器名称或IP ：</strong>HTTP请求发送的目标服务器名称或IP，格式如172.12.123.183</p>
<p><strong>端口号：</strong>目标服务器的端口号，默认为80 ，此例为9999</p>
<p><strong>方法：</strong>发送HTTP请求的方法，包括GET、POST、HEAD、PUT等。</p>
<p><strong>路径：</strong>去掉服务器地址、端口后剩余部分，此例为&#x2F;test&#x2F;v1</p>
<p><strong>编码方式：</strong>默认为ISO-8859-1，如请求中所传参数中包含中文，填写utf-8</p>
<p><img src="https://pic1.zhimg.com/80/v2-a4c3e662fa3f8d2cc6cbed96215922c0_720w.webp" alt="img"></p>
<p><strong>在请求中添加参数：</strong></p>
<p>如需在请求中发送参数，注意参数含中文时需要勾选“URL Encode编码”，并在编码方式填写utf-8。</p>
<p><img src="https://pic3.zhimg.com/80/v2-2ab95cbfe7f19d281f7d2282abbe6daa_720w.webp" alt="img"></p>
<p><strong>在请求中添加文件参数（图片&#x2F;音频&#x2F;视频等）:</strong></p>
<p>如需在请求中添加文件作为参数，选择Files Upload文件上传，点击Browser进行文件选择，在Parameter Name中填入参数名，在MIME Type中选择对应的MIME类型。如png图片对应为image&#x2F;png，jpg为image&#x2F;png，mp4为video&#x2F;mp4。</p>
<p><img src="https://pic2.zhimg.com/80/v2-35ec8249054ba3e144572258ef76342d_720w.webp" alt="img"></p>
<h3 id="3-4-添加结果树视图-x2F-聚合视图"><a href="#3-4-添加结果树视图-x2F-聚合视图" class="headerlink" title="3.4 添加结果树视图&#x2F;聚合视图"></a>3.4 添加结果树视图&#x2F;聚合视图</h3><p>右键点击“Thread线程组”-“Add添加”-“Listener监听器”-“View Results Tree结果树视图”及“Summary Report聚合视图” 。具体的指标含义在最后一节中再介绍，此处只要无脑添加一下即可。</p>
<p><img src="https://pic1.zhimg.com/80/v2-73441bcfea2da5c9ddaff5ac03c238b4_720w.webp" alt="img"></p>
<h3 id="3-5-执行性能测试-x2F-并发测试"><a href="#3-5-执行性能测试-x2F-并发测试" class="headerlink" title="3.5 执行性能测试&#x2F;并发测试"></a>3.5 执行性能测试&#x2F;并发测试</h3><p>点击Thread Group线程组，根据自己的需求设置参数：线程数，循环次数，持续时间等，下图设置并发数为20，循环数为2。按上方的绿色小三角即可运行，按右侧的扫帚图标即可清除历史记录。</p>
<p><img src="https://pic1.zhimg.com/80/v2-5a9899d575eaf3043a1a0b69c4e31688_720w.webp" alt="img"></p>
<h3 id="3-6-测试报告解读"><a href="#3-6-测试报告解读" class="headerlink" title="3.6 测试报告解读"></a>3.6 测试报告解读</h3><p><strong>结果树视图：</strong></p>
<p>在结果树视图可以看到各个请求的具体响应结果，Reponse data-Response Body里可以看到请求的响应内容，也可以查看获取的html界面。</p>
<p><img src="https://pic3.zhimg.com/80/v2-81e455383f9f0b8c9a3022f7a3821eba_720w.webp" alt="img"></p>
<p><strong>聚合视图：</strong></p>
<p>聚合视图则是对并发测试最好的分析报告。</p>
<p><img src="https://pic4.zhimg.com/80/v2-e007193e13ef2b442d4616b65a8bbca3_720w.webp" alt="img"></p>
<p>一般而言，并发测试重点关注的数据有： Samples请求数，Average平均响应时间，Min最小响应时间，Max最大响应时间，Error%错误率及Throughput吞吐量。其中，<strong>Error%错误率表示</strong>错误请求数&#x2F;请求总数，<strong>Throughput吞吐量</strong>表示单位时间完成的请求数。</p>
<p>除了<strong>结果树视图</strong>和<strong>聚合视图</strong>，JMeter还提供了很多其他的报告种类，大家可以自己在Lister监听器中尝试添加使用。</p>
]]></content>
      
        
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot项目分层与层级理解]]></title>
      <url>/2023/05/22/SpringBoot%E9%A1%B9%E7%9B%AE%E5%88%86%E5%B1%82%E4%B8%8E%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>最近正在学习springboot项目的底层原理，下面总结以下springBoot的项目分层结构与对于整体的层级架构理解</p>
<h1 id="SpringBoot项目分层"><a href="#SpringBoot项目分层" class="headerlink" title="SpringBoot项目分层"></a>SpringBoot项目分层</h1><h2 id="SpringBoot简单分层"><a href="#SpringBoot简单分层" class="headerlink" title="SpringBoot简单分层"></a>SpringBoot简单分层</h2><blockquote>
<ul>
<li><strong>controller</strong>：编写后端提供前端的接口。</li>
<li><strong>entity</strong>：主要放实体类Bean。</li>
<li><strong>service</strong>：业务层，编写复杂的服务功能，例如：复杂的数据库操作等。</li>
<li><strong>impl</strong>：整合service和dao层内容，提供后端完整接口调用。</li>
<li><strong>mapper</strong>:放Mybatis的xml文件。</li>
<li><strong>dao</strong>：与在mapper中Mybatis的xml中，sql语句相互形成映射关系，一般为对应实体类简单数据库操作的接口。</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="springboot的MVC分层方式"><a href="#springboot的MVC分层方式" class="headerlink" title="springboot的MVC分层方式"></a>springboot的MVC分层方式</h2><blockquote>
<p><strong>demo-model</strong>：主要是后端代码与数据库数据之间的交互。存放mybatis的相关文件，有config配置文件、entity实体类、mapper接口等。<br><strong>demo-service</strong>：主要业务层，编写复杂功能，提供impl接口。<br><strong>demo-web</strong>：后端给前端提供的接口，主要存放controller。<br><strong>start</strong>：只做启动和测试使用。</p>
</blockquote>
<h2 id="具体分层架构"><a href="#具体分层架构" class="headerlink" title="具体分层架构"></a>具体分层架构</h2><ul>
<li>demo-api：为后端与后端交互而提供的接口服务。</li>
<li>demo-dao：后端与数据库直接交互的地方。</li>
<li>demo-manager：代码管理层。</li>
<li>demo-service：复杂业务层。</li>
<li>demo-web：为前端提供接口。</li>
<li>start：启动和测试使用。</li>
</ul>
<h2 id="COLA分层"><a href="#COLA分层" class="headerlink" title="COLA分层"></a>COLA分层</h2><p>大型企业项目分层</p>
<h1 id="SpringBoot层级理解"><a href="#SpringBoot层级理解" class="headerlink" title="SpringBoot层级理解"></a>SpringBoot层级理解</h1><h2 id="model（entity）"><a href="#model（entity）" class="headerlink" title="model（entity）"></a>model（entity）</h2><blockquote>
<p>model是模型的意思，与entity、domain、pojo类似，是存放实体的类，类中定义了多个类属性，并与数据库表的字段保持一致，一张表对应一个model类。<br>主要用于定义与数据库对象应的属性，提供get&#x2F;set方法,tostring方法,有参无参构造函数。</p>
</blockquote>
<h2 id="dao（mapper）"><a href="#dao（mapper）" class="headerlink" title="dao（mapper）"></a>dao（mapper）</h2><blockquote>
<p>又被成为mapper层，叫数据持久层，先设计接口，然后在配置文件中进行配置其实现的关联。<br>dao层的作用为访问数据库，向数据库发送sql语句，完成数据的增删改查任务。<br>数据持久化操作就是指，把数据放到持久化的介质中，同时提供增删改查操作，比如数据通过hibernate插入到数据库中</p>
</blockquote>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><blockquote>
<p>业务逻辑层，完成功能的设计和dao层一样都是先设计接口，再创建要实现的类，然后在配置文件中进行配置其实现的关联。接下来就可以在service层调用dao层的接口进行业务逻辑应用的处理。<br>service的impl是把mapper和service进行整合的文件<br>封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。</p>
</blockquote>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><blockquote>
<p>控制层，控制业务逻辑service，控制请求和响应，负责前后端交互<br>controller层主要调用Service层里面的接口控制具体的业务流程，控制的配置也要在配置文件中进行</p>
</blockquote>
<h2 id="层次结构图"><a href="#层次结构图" class="headerlink" title="层次结构图"></a>层次结构图</h2><img src="C:\Users\22807\AppData\Roaming\Typora\typora-user-images\image-20230522011812169.png" alt="image-20230522011812169" style="zoom:80%;" />
]]></content>
      
        
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动态规划算法的打印思路]]></title>
      <url>/2023/05/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%93%E5%8D%B0%E6%80%9D%E8%B7%AF/</url>
      <content type="html"><![CDATA[<p>每次用动态规划求最佳值问题的时候，总会想到一个问题，该如何将每一种结果打印到控制台中呢？下面两段实例说不定会给你新的思路</p>
<h3 id="零钱兑换I-and-零钱兑换II"><a href="#零钱兑换I-and-零钱兑换II" class="headerlink" title="零钱兑换I and  零钱兑换II"></a>零钱兑换I and  零钱兑换II</h3><h4 id="1-零钱兑换I："><a href="#1-零钱兑换I：" class="headerlink" title="(1)零钱兑换I："></a>(1)零钱兑换I：</h4><p>贪心算法</p>
<p>伪代码描述思想：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">完全背包之求凑满背包的最少物品数:</span><br><span class="line">容量-&gt;amount; 物品重量-&gt;coins[i]; 价值-&gt;<span class="number">1</span>; 优化目标-&gt;求恰好凑满背包的物品最小价值</span><br><span class="line"><span class="number">1.</span>状态定义:dp[j]为凑满容量为j的背包所需最少物品数</span><br><span class="line"><span class="number">2.</span>状态转移:考虑coins[i]</span><br><span class="line">    <span class="number">2.1</span> 当j&lt;coins[i]时:装不下,继承上一个dp[j]的值</span><br><span class="line">    <span class="number">2.2</span> 当j&gt;=coins[i]时:可以装得下,可以选择装或者不装中价值小的(物品数小的)进行转移</span><br><span class="line">        即:dp[j]=min(dp[j],dp[j-coins[i]+<span class="number">1</span>])</span><br><span class="line"><span class="number">3.</span>初始化:容量为<span class="number">0</span>,最少要装<span class="number">0</span>个就可以装满-&gt;dp[<span class="number">0</span>]=<span class="number">0</span>,看转移方程,其他的要初始化为Integer.MAX_VALUE</span><br><span class="line"><span class="number">4.</span>遍历顺序:这里求最少的物品数,因此排列与组合均可,这里先物品后容量,物品顺序无所谓,容量必须正序(完全背包)</span><br><span class="line"><span class="number">5.</span>返回形式:返回如果dp[amount]有转移直接返回,如果没有转移返回-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 正序,j从coin开始即可</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coin; j &lt;= amount; j++) &#123;</span><br><span class="line">                <span class="comment">// 前面dp值在有计算过的基础上才能转移</span></span><br><span class="line">                <span class="keyword">if</span>(dp[j - coin] != Integer.MAX_VALUE) dp[j] = Math.min(dp[j], dp[j - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有转移直接返回,没有转移说明凑不成返回-1</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>动态规划背包问题</p>
<p>​           递归公式-&gt;遍历顺序</p>
</blockquote>
<h4 id="2-零钱兑换II：打印零钱兑换组合："><a href="#2-零钱兑换II：打印零钱兑换组合：" class="headerlink" title="(2)零钱兑换II：打印零钱兑换组合："></a>(2)零钱兑换II：打印零钱兑换组合：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//amou:未兑换为零钱的金额，step：步骤数组，len：步骤数，coins：零钱数组，m：零钱种类数，k：用于跳过重复组合的标志</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amou , <span class="type">int</span> *steps , <span class="type">int</span> len , <span class="type">int</span> *coins, <span class="type">int</span> m ,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amou == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; len ; i++ )&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span> , steps[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = k ; j &lt; m ; j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(amou &gt;= coins[j])&#123;</span><br><span class="line"></span><br><span class="line">                steps[len] = coins[j];</span><br><span class="line"></span><br><span class="line">                change(amou-coins[j] , steps , len+<span class="number">1</span> , coins , m, j );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>* coins, <span class="type">int</span> coinsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> dp[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coinsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">            dp[j] += dp[j - coins[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> steps[n];</span><br><span class="line">    <span class="type">int</span> coins[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count = change(n,coins,<span class="number">3</span>) ;</span><br><span class="line">    change(n,steps,<span class="number">0</span>,coins,<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d兑换为零钱有以上%d种组合情况&quot;</span>,n,count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="爬楼梯问题以及如何将组合数打印出来"><a href="#爬楼梯问题以及如何将组合数打印出来" class="headerlink" title="爬楼梯问题以及如何将组合数打印出来"></a>爬楼梯问题以及如何将组合数打印出来</h3><blockquote>
<p>使用递归函数打印所有可能的路径。我们可以修改动态编程解决方案，以跟踪到达每个楼梯所需的步骤。然后，我们可以使用递归函数根据所采取的步骤打印所有可能的路径。</p>
<p><strong>printPaths</strong>函数有三个参数：n是要爬的剩余楼梯数，steps是迄今为止所走步骤的数组，len是步骤数组的长度。我们从一个空的steps数组开始，调用<strong>printPaths</strong>函数，其中n等于楼梯总数。根据下一步是1还是2，函数递归调用自身，n减少1或2。当n达到0时，我们打印步骤数组。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">printPaths</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *steps, <span class="type">int</span> len)</span> &#123;<span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, steps[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">1</span>) &#123;   <span class="comment">//一步</span></span><br><span class="line">        steps[len] = <span class="number">1</span>;</span><br><span class="line">        printPaths(n<span class="number">-1</span>, steps, len+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">2</span>) &#123;  <span class="comment">//两步</span></span><br><span class="line">        steps[len] = <span class="number">2</span>;</span><br><span class="line">        printPaths(n<span class="number">-2</span>, steps, len+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;            </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> dp[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> steps[n];</span><br><span class="line">    printPaths(n, steps, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    climbStairs(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tip：java参数传递与c参数传递"><a href="#tip：java参数传递与c参数传递" class="headerlink" title="tip：java参数传递与c参数传递"></a>tip：java参数传递与c参数传递</h3><p>java中基本数据类型传值时不会影响主方法中的定义值的；而作为引用数据类型的数组（包括面向对象中的对象作为方法参数的时候）则会受到影响。</p>
<p>c语言中：</p>
<p><strong>sizeof(a)无法得到数组的大小。为什么会这样？因为把数组作为参数传递给函数时，实际上只有数组的首地址作为指针传递给了函数。换句话说，在函数</strong> <em>*<em>*定义中的int a[]*</em>*<em>等价于*</em>*<em>int *a*</em>*<em>。在只有地址信息的情况下，是无法知道数组里有多少个元素*</em>*</em> <strong>的。</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java注解机制与junit单元测试框架]]></title>
      <url>/2023/05/21/Java%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6%E4%B8%8Ejunit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<p>项目构建过程中很多地方需要用到注解，并且需要对每块功能做测试，那么注解到底是什么，该如何自定义注解？junit单元测试的使用方法？</p>
<span id="more"></span>

<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#Annotation_1">注解(Annotation)概述</a></li>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#Annotation_10">常见的Annotation实例</a></li>
<li><ul>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#_16">情况一</a></li>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#_31">情况二</a></li>
</ul>
</li>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#Annotation_58">自定义Annotation</a></li>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#JDK_80">JDK中的元注解</a></li>
<li><ul>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#Retention_97">@Retention</a></li>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#Target_128">@Target</a></li>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#Documented_196">@Documented</a></li>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#Inherited_201">@Inherited</a></li>
</ul>
</li>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#JDK8_204">JDK8中注解的新特性</a></li>
<li><ul>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#_209">可重复注解</a></li>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#_264">类型注解</a></li>
</ul>
</li>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#JUnit_315">JUnit单元测试</a></li>
<li><ul>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#_317">测试分类</a></li>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#JUnit_329">JUnit单元测试介绍</a></li>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#JUnitjar_339">引入本地JUnit.jar</a></li>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#Test_382">编写和运行@Test单元测试方法</a></li>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#JUnit_415">设置执行JUnit用例时支持控制台输入</a></li>
<li><a href="https://www.bmabk.com/index.php/post/122326.html#test_442">定义test测试方法模板</a></li>
</ul>
</li>
</ul>
<h1 id="注解-Annotation-概述"><a href="#注解-Annotation-概述" class="headerlink" title="注解(Annotation)概述"></a>注解(Annotation)概述</h1><ul>
<li>① 从 JDK 5.0 开始, <a href="https://www.bmabk.com/"><strong>java</strong></a> 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)</li>
<li>② Annotation 其实就是代码里的<strong>特殊标记</strong>, <strong>这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理</strong>。<strong>通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息</strong>。</li>
<li>③Annotation 可以像修饰符一样被使用, 可用于<strong>修饰包</strong>,<strong>类</strong>, <strong>构造器</strong>, <strong>方法</strong>, <strong>成员变量</strong>, <strong>参数</strong>, <strong>局部变量</strong>的声明, 这些信息被保存在Annotation 的 “name&#x3D;value” 对中。</li>
<li>④在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE&#x2F;Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</li>
<li>⑤未来的开发模式都是基于注解的，JPA是基于注解的，<a href="https://www.bmabk.com/"><strong>spring</strong></a>2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：<strong>框架 &#x3D; 注解 + 反射 + 设计模式</strong>。</li>
</ul>
<h1 id="常见的Annotation实例"><a href="#常见的Annotation实例" class="headerlink" title="常见的Annotation实例"></a>常见的Annotation实例</h1><ul>
<li>①生成文档相关的注释</li>
<li>②在编译时进行格式检查(JDK内置的三个基本注解)</li>
<li>③跟踪代码依赖性，实现替代配置文件功能</li>
</ul>
<h2 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h2><p>@author 标明开发该类模块的作者，多个作者之间使用“,”分割<br>@version 标明该类模块的版本<br>@see 参考转向，也就是相关主题<br>@since 从哪个版本开始增加的<br>@param 对方法中某参数的说明，如果没有参数就不能写<br>@return 对方法返回值的说明，如果方法的返回值类型是void就不能写<br>@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写<br>其中<br>@param @return 和 @exception 这三个标记都是只用于方法的。<br>@param的格式要求：@param 形参名 形参类型 形参说明<br>@return 的格式要求：@return 返回值类型 返回值说明<br>@exception的格式要求：@exception 异常类型 异常说明<br>@param和@exception可以并列多个</p>
<h2 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h2><ul>
<li>@Override: 限定重写父类方法, 该注解只能用于方法</li>
<li>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为<br>所修饰的结构危险或存在更好的选择</li>
<li>@SuppressWarnings: 抑制编译器警告</li>
</ul>
<p><strong>说明</strong>：为什么要用@Override？直接重写当然也可以，当用@Override的时候编译器会自动帮你检测你是否进行了重写，这也就为你的程序提供了一个保障。避免了重写的时候输错了重写的方法名，而导致并没有重写父类中的方法的情况。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;  <span class="comment">//在编译器中这种过时的的方法都会被画一条线</span></span><br><span class="line">		System.out.println(<span class="string">&quot;过时的方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;重写的toString方法()&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义Annotation"><a href="#自定义Annotation" class="headerlink" title="自定义Annotation"></a>自定义Annotation</h1><p><strong>注意点</strong>：</p>
<ul>
<li>定义新的 Annotation 类型使用 @interface 关键字</li>
<li>自定义注解自动继承了java.lang.annotation.Annotation接口</li>
<li>Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是<strong>八种基本数据类型、String类型、Class类型、enum类型Annotation类型、以上所有类型的数组</strong>。</li>
<li>可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 <strong>default 关键字</strong></li>
<li>如果只有一个参数成员，建议使用参数名为value</li>
<li><strong>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值</strong>。格式是“参数名 &#x3D; 参数值”，如果只有一个参数成员，且名称为value，可以省略“value&#x3D;”</li>
<li>没有成员定义的 Annotation 称为<strong>标记</strong>; 包含成员变量的 Annotation 称为元数据 Annotation</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个注解到底有什么作用，在反射和框架中会提到。<br><strong>自定义注解必须配上注解的信息处理流程才有意义</strong>。</p>
<h1 id="JDK中的元注解"><a href="#JDK中的元注解" class="headerlink" title="JDK中的元注解"></a>JDK中的元注解</h1><p>在理解元注解之前我们先理解元数据。那么什么是元数据呢，我们可以先看看下面的一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;CSDN&quot;</span><br></pre></td></tr></table></figure>

<p>一个简单的赋值语句，在这个句子中我们可以说CSDN才是最主要的，他是真正我们想要的数据，而前面的String，name等这些东西都是起到一种修饰的作用，所以我们称它们为<strong>元数据</strong>。<strong>也就是说对现有数据进行修饰的数据</strong>。那么同理我们也可以知道元注解的意思。</p>
<p><strong>元注解：对现有的注解进行解释说明的注解</strong></p>
<p>JDK5.0提供了4个标准的meta-annotation(元注解)类型：</p>
<ul>
<li>Retention（一般自定义注解会指明）</li>
<li>Target（一般自定义注解会指明）</li>
<li>Documented（出现频率低）</li>
<li>Inherited（出现频率低）</li>
</ul>
<h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h2><p>只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值。<br><strong>注</strong>：这个RetentionPolicy是一个枚举类，它有三个对象分别是 SOURCE,CLASS,RUNTIME</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum RetentionPolicy&#123;</span><br><span class="line">	SOURCE,</span><br><span class="line">	CLASS,</span><br><span class="line">	RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Rentention 成员变量的几个指定值：</p>
<ul>
<li>RetentionPolicy.SOURCE:在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释</li>
<li>RetentionPolicy.CLASS:在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM 不会保留注解。 <strong>这是默认值</strong>。</li>
<li>RetentionPolicy.RUNTIME:在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释。<strong>程序可以通过反射获取该注释</strong>。</li>
</ul>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">@interface MyAnnotation1&#123; &#125;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@interface MyAnnotation2&#123; &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4893383a-b9ac-11ed-aee5-5cea1d84200c.png#pic_center"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4893383a-b9ac-11ed-aee5-5cea1d84200c.png#pic_center" alt="生命周期"></a><br>也就是说<strong>只有声明为RUNTIME生命周期的注解，才能通过反射获取</strong></p>
<h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p>用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。</p>
<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/48cea679-b9ac-11ed-8678-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/48cea679-b9ac-11ed-8678-5cea1d84200c.png" alt="target"></a><br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface SuppressWarnings &#123;········&#125;</span><br></pre></td></tr></table></figure>

<p>而在Target中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个ElementType同样也是一个枚举类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h2><p>用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。</p>
<p><strong>注意</strong>：定义为Documented的注解必须设置Retention值为RUNTIME。</p>
<h2 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h2><p>被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。</p>
<h1 id="JDK8中注解的新特性"><a href="#JDK8中注解的新特性" class="headerlink" title="JDK8中注解的新特性"></a>JDK8中注解的新特性</h1><ul>
<li>可重复注解</li>
<li>类型注解</li>
</ul>
<h2 id="可重复注解"><a href="#可重复注解" class="headerlink" title="可重复注解"></a>可重复注解</h2><p>例如现在我要给Person类添加两个同类型的注解MyAnnotation。<br>在JDK8以前：<br>要先定义一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public @interface MyAnnotations &#123;</span><br><span class="line"></span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@MyAnnotations(&#123;@MyAnnotation(value=&quot;hi&quot;),@MyAnnotation(value=&quot;hi&quot;)&#125;)</span><br><span class="line">class Person&#123;······&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说相当于定义了一个数组可以把多个都装起来。</p>
<p>而在JDK8以后，有了可重复注解的特性：</p>
<ul>
<li>① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class</li>
<li>② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。（如此编译时能通过，但发现在运行时不过，也就是说@Inherited也要相同）</li>
</ul>
<p>相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line"></span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@MyAnnotation(value=&quot;hi&quot;)</span><br><span class="line">@MyAnnotation(value=&quot;abc&quot;)</span><br><span class="line">class Person&#123;······&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>就是Target元注解新增了两个值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Type parameter declaration</span><br><span class="line"> *</span><br><span class="line"> * @since 1.8</span><br><span class="line"> */</span><br><span class="line">TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Use of a type</span><br><span class="line"> *</span><br><span class="line"> * @since 1.8</span><br><span class="line"> */</span><br><span class="line">TYPE_USE</span><br></pre></td></tr></table></figure>

<ul>
<li>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）</li>
<li>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</li>
</ul>
<p>例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Generic</span>&lt;<span class="meta">@MyAnnotation</span> T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> <span class="keyword">throws</span> <span class="meta">@MyAnnotation</span> RuntimeException&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;<span class="meta">@MyAnnotation</span> String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="meta">@MyAnnotation</span> <span class="type">int</span>) <span class="number">10L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个注解能去修饰泛型，就是因为Target中加入了TYPE_PARAMETER<br>后面三个注解能这么使用，是因为Target中加入了TYPE_USE。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JUnit单元测试"><a href="#JUnit单元测试" class="headerlink" title="JUnit单元测试"></a>JUnit单元测试</h1><h2 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h2><p><strong>黑盒测试：</strong> 不需要写代码，给输入值，看程序是否能够输出期望的值。</p>
<p><strong>白盒测试：</strong> 需要写代码的。关注程序具体的执行流程。</p>
<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4924aa02-b9ac-11ed-9fa4-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4924aa02-b9ac-11ed-9fa4-5cea1d84200c.png" alt="在这里插入图片描述"></a></p>
<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/496b7186-b9ac-11ed-a2e6-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/496b7186-b9ac-11ed-a2e6-5cea1d84200c.png" alt="在这里插入图片描述"></a></p>
<h2 id="JUnit单元测试介绍"><a href="#JUnit单元测试介绍" class="headerlink" title="JUnit单元测试介绍"></a>JUnit单元测试介绍</h2><p>JUnit 是由 Erich Gamma 和 Kent Beck 编写的一个测试框架（regression testing framework），供Java开发人员编写单元测试之用。</p>
<p><strong>JUnit测试是程序员测试，即所谓白盒测试，因为程序员知道被测试的软件如何（How）完成功能和完成什么样（What）的功能。</strong></p>
<p>要使用JUnit，必须在项目的编译路径中<code>引入JUnit的库</code>，即相关的.class文件组成的jar包。jar就是一个压缩包，压缩包都是开发好的第三方（Oracle公司第一方，我们自己第二方，其他都是第三方）工具类，都是以class文件形式存在的。</p>
<h2 id="引入本地JUnit-jar"><a href="#引入本地JUnit-jar" class="headerlink" title="引入本地JUnit.jar"></a>引入本地JUnit.jar</h2><p>第1步：在项目中File-Project Structure中操作：添加Libraries库</p>
<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4997ad64-b9ac-11ed-961f-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4997ad64-b9ac-11ed-961f-5cea1d84200c.png" alt="在这里插入图片描述"></a></p>
<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/49d6b5de-b9ac-11ed-b9ec-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/49d6b5de-b9ac-11ed-b9ec-5cea1d84200c.png" alt="在这里插入图片描述"></a></p>
<p>其中，junit-libs包内容如下：</p>
<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4a04176a-b9ac-11ed-8669-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4a04176a-b9ac-11ed-8669-5cea1d84200c.png" alt="在这里插入图片描述"></a></p>
<blockquote>
<p>一定要注意Junit模块支持需要两个文件：hamcrest&amp;JUnit，如果少了hamcrest的jar包会报java.lang.Exception: No tests found matching</p>
</blockquote>
<p>第2步：选择要在哪些module中应用JUnit库</p>
<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4a3ec0aa-b9ac-11ed-94d7-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4a3ec0aa-b9ac-11ed-94d7-5cea1d84200c.png" alt="在这里插入图片描述"></a></p>
<p>第3步：检查是否应用成功</p>
<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4a7e99ff-b9ac-11ed-98bf-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4a7e99ff-b9ac-11ed-98bf-5cea1d84200c.png" alt="在这里插入图片描述"></a></p>
<p><strong>注意Scope：选择Compile，否则编译时，无法使用JUnit。</strong></p>
<p>第4步：下次如果有新的模块要使用该libs库，这样操作即可</p>
<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4aba48a7-b9ac-11ed-838e-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4aba48a7-b9ac-11ed-838e-5cea1d84200c.png" alt="在这里插入图片描述"></a></p>
<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4af7b744-b9ac-11ed-bcb9-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4af7b744-b9ac-11ed-bcb9-5cea1d84200c.png" alt="在这里插入图片描述"></a></p>
<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4b326b8f-b9ac-11ed-b863-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4b326b8f-b9ac-11ed-b863-5cea1d84200c.png" alt="在这里插入图片描述"></a></p>
<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4b6ee8fc-b9ac-11ed-82b3-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4b6ee8fc-b9ac-11ed-82b3-5cea1d84200c.png" alt="在这里插入图片描述"></a></p>
<h2 id="编写和运行-Test单元测试方法"><a href="#编写和运行-Test单元测试方法" class="headerlink" title="编写和运行@Test单元测试方法"></a>编写和运行@Test单元测试方法</h2><p>JUnit4版本，要求@Test标记的方法必须满足如下要求：</p>
<ul>
<li>所在的类必须是public的，非抽象的，包含唯一的无参构造器。</li>
<li>@Test标记的方法本身必须是public，非抽象的，非静态的，void无返回值，()无参数的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.junit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJUnit</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestJUnit.test01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestJUnit.test02&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestJUnit.test03&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4b9ddcd0-b9ac-11ed-841f-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4b9ddcd0-b9ac-11ed-841f-5cea1d84200c.png" alt="在这里插入图片描述"></a></p>
<h2 id="设置执行JUnit用例时支持控制台输入"><a href="#设置执行JUnit用例时支持控制台输入" class="headerlink" title="设置执行JUnit用例时支持控制台输入"></a>设置执行JUnit用例时支持控制台输入</h2><p><strong>1. 设置数据：</strong></p>
<p>默认情况下，在单元测试方法中使用Scanner时，并不能实现控制台数据的输入。需要做如下设置：</p>
<p>在<code>**idea**64.exe.vmoptions配置文件</code>中加入下面一行设置，重启idea后生效。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-Deditable.java.test.console</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 配置文件位置：</strong></p>
<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4bd9a975-b9ac-11ed-adbc-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4bd9a975-b9ac-11ed-adbc-5cea1d84200c.png" alt="在这里插入图片描述"></a></p>
<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4c1e3f3f-b9ac-11ed-be42-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4c1e3f3f-b9ac-11ed-be42-5cea1d84200c.png" alt="在这里插入图片描述"></a></p>
<p>添加完成之后，重启IDEA即可。</p>
<p><strong>3. 如果上述位置设置不成功，需要继续修改如下位置</strong></p>
<p>修改位置1：IDEA安装目录的bin目录（例如：<code>D:\develop_tools\IDEA\IntelliJ IDEA 2022.1.2\bin</code>）下的idea64.exe.vmoptions文件。</p>
<p>修改位置2：C盘的用户目录<code>C:\Users\用户名\AppData\Roaming\JetBrains\IntelliJIdea2022.1</code> 下的idea64.exe.vmoptions&#96;件。</p>
<h2 id="定义test测试方法模板"><a href="#定义test测试方法模板" class="headerlink" title="定义test测试方法模板"></a>定义test测试方法模板</h2><p>选中自定义的模板组，点击”+”（1.Live Template）来定义模板。</p>
<p><a href="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4c58f8fc-b9ac-11ed-9556-5cea1d84200c.png"><img src="https://blog-1305504063.cos.ap-beijing.myqcloud.com/4c58f8fc-b9ac-11ed-9556-5cea1d84200c.png" alt="在这里插入图片描述"></a></p>
]]></content>
      
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[socket网络编程实战（java）]]></title>
      <url>/2023/04/24/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%88java%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>一些关于java socket通信编程的实例解释</p>
<h3 id="1-需求：客户端实现步骤："><a href="#1-需求：客户端实现步骤：" class="headerlink" title="1.需求：客户端实现步骤："></a>1.需求：客户端实现步骤：</h3><ul>
<li><p>创建客户端的socket对象，请求与服务端的连接。</p>
</li>
<li><p>使用socket对象调用getOutputStream（）方法得到字节输出流</p>
</li>
<li><p>使用字节输出流完成数据的发送</p>
</li>
<li><p>释放资源：关闭socket管道</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span> , <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line"></span><br><span class="line">            ps.print(<span class="string">&quot;I&#x27;m TCP client , have your time?&quot;</span>);</span><br><span class="line"></span><br><span class="line">            ps.flush();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="2-需求：客户端接收消息"><a href="#2-需求：客户端接收消息" class="headerlink" title="2.需求：客户端接收消息"></a>2.需求：客户端接收消息</h3><p>1.注册端口</p>
<p>2.连接socket通信管道，用端口接受信息</p>
<p>3.使用缓冲字符输入流接收消息</p>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建socket管道</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;192.168.57.1&quot;</span> , <span class="number">7777</span>);</span><br><span class="line">            <span class="comment">//从管道中得到一个字节输出流，负责发送数据</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="comment">//低级字节流 ---- 》 打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">            <span class="comment">//发送消息</span></span><br><span class="line">            ps.println(<span class="string">&quot;I&#x27;m TCP client , have your time?&quot;</span>);</span><br><span class="line"></span><br><span class="line">            ps.flush();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;server start!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注册端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//建立socket通信管道，调用accept接受信息</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 缓冲字符输入流</span></span><br><span class="line"></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line"></span><br><span class="line">            String msg;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;is saying:&quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-需求：使用TCP通信方式实现：多发多收"><a href="#3-需求：使用TCP通信方式实现：多发多收" class="headerlink" title="3.需求：使用TCP通信方式实现：多发多收"></a>3.需求：使用TCP通信方式实现：多发多收</h3><p>具体要求：</p>
<p>可以使用死循环服务端手腕消息继续wait next message client  can use    死循环    等待用户不断输入信息 客户端一旦输入exit关闭客户端程序，并且释放资源</p>
<p>4.服务端实现同时处理多个客户端请求</p>
<p>模型:</p>
<p><img src="https://res.craft.do/user/full/99fc6c46-0285-ec72-c3bf-f057caf908c9/doc/59be5336-7435-47b4-a3e5-5e6c232451f2/f884d92b-14d4-4a65-a7b0-c32d085e5f26" alt="img"></p>
<ul>
<li><p>主线程定义循环负责接收客户端Socket管道连接</p>
</li>
<li><p>每接受到一个Socket通信管道就分配一个独立的线程负责处理</p>
</li>
</ul>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 单线程只能与一个客户端进行通信</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;server start!&quot;</span>);</span><br><span class="line">            <span class="comment">//注册端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">7777</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//Create a socket communication pipe and call accept to receive messages</span></span><br><span class="line">                <span class="comment">//For each client pipeline received, a single thread is handed over to process the message</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;上线了&quot;</span>);</span><br><span class="line">                <span class="comment">//开启独立线程</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<p>实现多发多收：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建socket管道</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span> , <span class="number">7777</span>);</span><br><span class="line">            <span class="comment">//从管道中得到一个字节输出流，负责发送数据</span></span><br><span class="line">            <span class="comment">//A byte output stream from the pipeline, responsible for sending data</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="comment">//低级字节流 ---- 》 打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="comment">//output the message!</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; Please say :&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">                ps.println(msg);</span><br><span class="line"></span><br><span class="line">                ps.flush();<span class="comment">//refresh</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// ps.println(&quot;I&#x27;m TCP client , have your time?&quot;);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>线程类：</p>
<p>实现多个客户端发送消息的处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">// 缓冲字符输入流</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span>((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;is saying:&quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress()+ <span class="string">&quot;下线了！ &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-线程池优化方案"><a href="#4-线程池优化方案" class="headerlink" title="4.线程池优化方案"></a>4.线程池优化方案</h3><p>实际开发中针对于客户端与服务端之间的通不可能为每一个客户端与服务端开一个进程，所以对小型应用平台开发会用线程池进行通信技术的优化。</p>
<p>客户端代码保持不变，主要在服务端上面进行优化</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="comment">//static --&gt; 线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">POOL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span> , <span class="number">5</span> , <span class="number">6</span> , TimeUnit.SECONDS ,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>) , Executors.defaultThreadFactory() , <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 单线程只能与一个客户端进行通信</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;server start!&quot;</span>);</span><br><span class="line">            <span class="comment">//注册端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">7777</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//Create a socket communication pipe and call accept to receive messages</span></span><br><span class="line">                <span class="comment">//For each client pipeline received, a single thread is handed over to process the message</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;上线了&quot;</span>);</span><br><span class="line">                <span class="comment">//开启独立线程</span></span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerReaderRunnable</span>(socket);</span><br><span class="line">                POOL.execute(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runnable任务类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Socket socket;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">ServerReaderRunnable</span><span class="params">(Socket socket)</span></span><br><span class="line">     &#123; <span class="comment">//有参构造器</span></span><br><span class="line">         <span class="built_in">this</span>.socket = socket;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">// 缓冲字符输入流</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line"></span><br><span class="line">            String msg;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;is saying:&quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress()+ <span class="string">&quot;下线了！ &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="通信实战案例–即时通信（学习历程）"><a href="#通信实战案例–即时通信（学习历程）" class="headerlink" title="通信实战案例–即时通信（学习历程）"></a>通信实战案例–即时通信（学习历程）</h3><p>在上面实例中添加客户端接受转发消息功能。</p>
<p>需求：</p>
<p>1.客户端添加独立线程实现接受转发消息</p>
<p>2.服务端对收到的消息进行转发</p>
<p>关键点：定义管道socket队列list，每有一个客户端就加入一个socket进入list，在服务端进行转发的过程中将消息转发给每个客户端。</p>
<p>Client客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建socket管道</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span> , <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个独立的才能成负责接受来自服务端的转发消息</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ClientReaderThread</span>(socket).start();</span><br><span class="line">            <span class="comment">//从管道中得到一个字节输出流，负责发送数据</span></span><br><span class="line">            <span class="comment">//A byte output stream from the pipeline, responsible for sending data</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="comment">//低级字节流 ---- 》 打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="comment">//output the message!</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; Please say :&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                ps.println(msg);</span><br><span class="line">                ps.flush();<span class="comment">//refresh</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// ps.println(&quot;I&#x27;m TCP client , have your time?&quot;);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">             <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">public</span> <span class="title function_">ClientReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">                        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 缓冲字符输入流</span></span><br><span class="line"></span><br><span class="line">                      <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line"></span><br><span class="line">                      String msg;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">while</span>((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                          System.out.println(<span class="string">&quot;收到消息:&quot;</span> + msg);</span><br><span class="line">               &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress()+ <span class="string">&quot;服务端踢走！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>server端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个管道存放socket管道</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Socket&gt; allonLineSocket = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 单线程只能与一个客户端进行通信</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;server start!&quot;</span>);</span><br><span class="line">            <span class="comment">//注册端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">7777</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//Create a socket communication pipe and call accept to receive messages</span></span><br><span class="line">                <span class="comment">//For each client pipeline received, a single thread is handed over to process the message</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;上线了&quot;</span>);</span><br><span class="line">                allonLineSocket.add(socket);<span class="comment">//上线完成</span></span><br><span class="line">                <span class="comment">//开启独立线程</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">// 缓冲字符输入流</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span>((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;is saying:&quot;</span> + msg);</span><br><span class="line">                sendMsgtoAll(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress()+ <span class="string">&quot;下线了！ &quot;</span>);</span><br><span class="line">            ServerDemo2.allonLineSocket.remove(socket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsgtoAll</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">for</span>(Socket socket : ServerDemo2.allonLineSocket) &#123;</span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(socket.getOutputStream());</span><br><span class="line">            ps.println(msg);</span><br><span class="line">            ps.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip:"></a>Tip:</h3><h4 id="即时通信的含义"><a href="#即时通信的含义" class="headerlink" title="即时通信的含义"></a>即时通信的含义</h4><ul>
<li><p>即时通信是指一个客户端的消息发出，其他客户端也可以收到</p>
</li>
<li><p>即时通信需要进行端口转发的设计思想</p>
</li>
<li><p>服务端需要把在线的socket管道存储起来</p>
</li>
<li><p>一旦受到消息就要推送给其他管道</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[日志框架:logback快速入门]]></title>
      <url>/2023/04/24/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6-logback%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>java logback日志使用教程</p>
<h2 id="log-QU"><a href="#log-QU" class="headerlink" title="log QU"></a>log QU</h2><p>1.概述java logback日志使用教程</p>
<p>日志规范大多是一些接口 ， 提供给实现框架去设计的</p>
<p>常见规范：</p>
<p>Commons Logging</p>
<p>Simple Logging Facade for java</p>
<p>2.日志的实现框架有那些常见的？</p>
<p>Log4j</p>
<p>Logback日志框架（快速入门）</p>
<p>Logback是一个开源日志组件</p>
<p>是基于slf4j的日志规范实现的框架</p>
<span id="more"></span>

<p>3.技术模块：</p>
<p>logback-core : 是为其他两个模块奠定了基础，必须有</p>
<p>logback-classic: log4j的是一个改良版本，同时完整地实现了slf4j API</p>
<p>logback-access: 该模块与Tomcat和jetty等servlet容器集成，以提供HTTP昂问日志功能。</p>
<p>需要jar模块</p>
<p>logback-classic  jar</p>
<p>logback-core jar</p>
<p>slf4j-api jar</p>
<h2 id="Logback快速入门："><a href="#Logback快速入门：" class="headerlink" title="Logback快速入门："></a>Logback快速入门：</h2><p>1.在项目下新建文件夹lib ， 导入logback的相关jar包到该文件夹中，并添加到项目依赖库中 Add as library</p>
<p>jar包</p>
<p><a href="https://res.craft.do/user/full/99fc6c46-0285-ec72-c3bf-f057caf908c9/doc/59be5336-7435-47b4-a3e5-5e6c232451f2/edda3b87-037f-425c-8b62-d0d0030747f8">https://res.craft.do/user/full/99fc6c46-0285-ec72-c3bf-f057caf908c9/doc/59be5336-7435-47b4-a3e5-5e6c232451f2/edda3b87-037f-425c-8b62-d0d0030747f8</a></p>
<p><a href="https://res.craft.do/user/full/99fc6c46-0285-ec72-c3bf-f057caf908c9/doc/59be5336-7435-47b4-a3e5-5e6c232451f2/318472c0-9e7c-4ae1-a8bf-48620d0e6cf7">https://res.craft.do/user/full/99fc6c46-0285-ec72-c3bf-f057caf908c9/doc/59be5336-7435-47b4-a3e5-5e6c232451f2/318472c0-9e7c-4ae1-a8bf-48620d0e6cf7</a></p>
<p><a href="https://res.craft.do/user/full/99fc6c46-0285-ec72-c3bf-f057caf908c9/doc/59be5336-7435-47b4-a3e5-5e6c232451f2/83b8fc9f-bdcd-4fb8-8db3-422b219332fa">https://res.craft.do/user/full/99fc6c46-0285-ec72-c3bf-f057caf908c9/doc/59be5336-7435-47b4-a3e5-5e6c232451f2/83b8fc9f-bdcd-4fb8-8db3-422b219332fa</a></p>
<p>2.将Logback的核心配置文件logback.xml直接拷贝到src目录下（必须是src下）</p>
<p>logback.xml（修改文件名和目录即可使用）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>System.out<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志输出格式：%d表示日期时间，%-5level：日志级别  ，%c取类 %thread表示线程名(在哪个方法执行)，</span></span><br><span class="line"><span class="comment">                %msg：日志消息，%n是换行符 ，不会用就去百度一下logback的日志格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;[%-5level]  %c [%thread] :%msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125;-%msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志输出路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>C:/logback/work-date.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定日志文件拆分和压缩规则 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 通过指定压缩文件的名称，来确定分割文件方式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>C:/logback/work-data-%d&#123;yyyy-MMdd&#125;.log%i.gz<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 文件拆分大小 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>1MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- level:用来设计打印级别，大小写无关：TRACE,DEBUG,INFO,WARN,ERROR,ALL和OFF,默认debug</span></span><br><span class="line"><span class="comment">    &lt;root&gt;可以包含零个或多个&lt;appender-ref&gt;元素,标识这个输出位置将会被本日志级别控制。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;ALL&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注意：如果这里不配置关联打印位置，该位置将不会记录日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="logse"><a href="#logse" class="headerlink" title="logse"></a>logse</h3><p>在这里有些小伙伴的idea中右键src文件没有xml文件格式，不要急，按下面步骤配置idea即可。</p>
<ul>
<li><p>File ––&gt; setting —–&gt; Editor—–&gt; File and Code Templates—–&gt; Files(点击”+”)  </p>
</li>
<li><p>修改Name为XML File    修改Extension为xml ，在下面增加xml模板语言：</p>
</li>
<li><p>最后勾选Enable live Templates √  ok即可</p>
</li>
<li><p>右击src即可创建xml文件格式</p>
</li>
</ul>
<p><img src="https://res.craft.do/user/full/99fc6c46-0285-ec72-c3bf-f057caf908c9/doc/59be5336-7435-47b4-a3e5-5e6c232451f2/d07b4e3e-5b7d-480b-97f7-b7c086bbe007" alt="img"></p>
<ul>
<li>在代码中获取日志对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;类对象&quot;</span>); </span><br></pre></td></tr></table></figure>



<h2 id="Logback的API操作："><a href="#Logback的API操作：" class="headerlink" title="Logback的API操作："></a>Logback的API操作：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> getLogger(name)：获取一个name命名的Logger实例，name可以是类名，也可以是任意字符串。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> getLogger(Class)：获取一个以传入类名命名的Logger实例。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> trace(String msg)：记录跟踪级别的日志信息。 （LOGGER.trace(<span class="string">&quot;a=&quot;</span> +a);）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> debug(String msg)：记录调试级别的日志信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> info(String msg)：记录信息级别的日志信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> warn(String msg)：记录警告级别的日志信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> error(String msg)：记录错误级别的日志信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> addAppender(Appender)：添加Appender实例到当前Logger实例中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> removeAppender(Appender)：从当前Logger实例中移除指定的Appender实例。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">10.</span> setLevel(Level)：设置当前Logger实例的日志级别。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">11.</span> setAdditive(<span class="type">boolean</span>)：设置当前Logger实例是否将日志事件传递到其父Logger实例。若为<span class="literal">true</span>，则会传递到父Logger实例。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">12.</span> addFilter(Filter)：添加一个Filter实例到当前Logger实例中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">13.</span> detachAndStopAllAppenders()：从当前Logger实例中移除所有Appender实例，并停止它们。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">14.</span> detachAppender(String)：从当前Logger实例中移除指定名称的Appender实例。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">15.</span> removeAllAppenders()：从当前Logger实例中移除所有Appender实例。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">16.</span> log(Level, String)：记录指定级别的日志信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">17.</span> getLevel()：获取当前Logger实例的日志级别。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">18.</span> isTraceEnabled()：判断当前Logger实例的跟踪级别是否启用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">19.</span> isDebugEnabled()：判断当前Logger实例的调试级别是否启用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">20.</span> isInfoEnabled()：判断当前Logger实例的信息级别是否启用。</span><br></pre></td></tr></table></figure>



<h3 id="一段log实例："><a href="#一段log实例：" class="headerlink" title="一段log实例："></a>一段log实例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogExample</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(LogExample.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LOGGER.trace(<span class="string">&quot;Trace Message&quot;</span>);</span><br><span class="line">    LOGGER.debug(<span class="string">&quot;Debug Message&quot;</span>);</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Info Message&quot;</span>);</span><br><span class="line">    LOGGER.warn(<span class="string">&quot;Warn Message&quot;</span>);</span><br><span class="line">    LOGGER.error(<span class="string">&quot;Error Message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//[main] TRACE LogExample - Trace Message</span></span><br><span class="line"><span class="comment">//[main] DEBUG LogExample - Debug Message</span></span><br><span class="line"><span class="comment">//[main] INFO LogExample - Info Message</span></span><br><span class="line"><span class="comment">//[main] WARN LogExample - Warn Message</span></span><br><span class="line"><span class="comment">//[main] ERROR LogExample - Error Message系统中哪些日志将被输出打印</span></span><br></pre></td></tr></table></figure>

<h3 id="logla"><a href="#logla" class="headerlink" title="logla"></a>logla</h3><ul>
<li><p>设置日志输出级别的作用：控制系统中哪些日志将被输出打印</p>
</li>
<li><p>日志级别：TRACE,DEBUG,INFO,WARN,ERROR （从小到大） </p>
</li>
<li><p>ALL打开全部日志 | OFF关闭全部日志  （权限再logback.xml文件中修改level，只能打印对应级别或以上级别的才会被跟踪）</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java移位表达式]]></title>
      <url>/2023/04/22/java%E7%A7%BB%E4%BD%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>在 Java 代码里使用 &lt;&lt; 、 &gt;&gt; 和&gt;&gt;&gt;转换成的指令码运行起来会更高效些。</p>
<p>掌握最基本的移位运算符知识还是很有必要的，这不光可以帮助我们在代码中使用，还可以帮助我们理解源码中涉及到移位运算符的代码。</p>
<span id="more"></span>

<p>Java 中有三种移位运算符：</p>
<p>&lt;&lt; :左移运算符，向左移若干位，高位丢弃，低位补零。x &lt;&lt; 1,相当于 x 乘以 2(不溢出的情况下)。</p>
<p>&gt;&gt; :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x &gt;&gt; 1,相当于 x 除以 2。 </p>
<p>&gt;&gt;&gt; :无符号右移，忽略符号位，空位都以 0 补齐。</p>
<p>由于 double，float 在二进制中的表现比较特殊，因此不能来进行移位操作。</p>
<p>移位操作符实际上支持的类型只有int和long，编译器在对short、byte、char类型进行移位前，都会将其转换为int类型再操作。</p>
<p>如果移位的位数超过数值所占有的位数会怎样？</p>
<p>当 int 类型左移&#x2F;右移位数大于等于 32 位操作时，会先求余（%）后再进行左移&#x2F;右移操作。也就是说左移&#x2F;右移 32 位相当于不进行移位操作（32%32&#x3D;0），左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位（42%32&#x3D;10）。当 long 类型进行左移&#x2F;右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。</p>
<p>也就是说：x&lt;&lt;42等同于x&lt;&lt;10，x&gt;&gt;42等同于x&gt;&gt;10，x &gt;&gt;&gt;42等同于x &gt;&gt;&gt; 10。</p>
<p>左移运算符代码示例 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>; System.out.println(<span class="string">&quot;初始数据： &quot;</span> + i); </span><br><span class="line">System.out.println(<span class="string">&quot;初始数据对应的二进制字符串： &quot;</span> + Integer.toBinaryString(i));</span><br><span class="line">i &lt;&lt;= <span class="number">10</span>; </span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据 &quot;</span> + i); </span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据对应的二进制字符 &quot;</span> + Integer.toBinaryString(i));</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>初始数据： -1 初始数据对应的二进制字符串： 11111111111111111111111111111111 左移 10 位后的数据 -1024 左移 10 位后的数据对应的二进制字符 11111111111111111111110000000000</p>
<p>由于左移位数大于等于 32 位操作时，会先求余（%）后再进行左移操作，所以下面的代码左移 42 位相当于左移 10 位（42%32&#x3D;10），输出结果和前面的代码一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>; System.out.println(<span class="string">&quot;初始数据： &quot;</span> + i); </span><br><span class="line">System.out.println(<span class="string">&quot;初始数据对应的二进制字符串： &quot;</span> + Integer.toBinaryString(i)); </span><br><span class="line">i &lt;&lt;= <span class="number">42</span>; </span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据 &quot;</span> + i); </span><br><span class="line">System.out.println(<span class="string">&quot;左移 10 位后的数据对应的二进制字符 &quot;</span> + Integer.toBinaryString(i));</span><br></pre></td></tr></table></figure>

]]></content>
      
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[发布博客！]]></title>
      <url>/2023/04/21/%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B8%83/</url>
      <content type="html"><![CDATA[<h3 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">npm i hexo-deployer-git</span><br><span class="line">PLAINTEXT</span><br><span class="line">hexo new post &quot;新建博客文章名&quot;</span><br><span class="line">PLAINTEXT</span><br><span class="line">hexo cl &amp;&amp; hexo g  &amp;&amp; hexo s</span><br><span class="line">远端提交</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[一些对于POJO的理解（Spring）]]></title>
      <url>/2023/03/22/%E4%B8%80%E4%BA%9B%E5%AF%B9%E4%BA%8EPOJO%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88Spring%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="一些对POJO的理解（Spring）"><a href="#一些对POJO的理解（Spring）" class="headerlink" title="一些对POJO的理解（Spring）"></a>一些对POJO的理解（Spring）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直想对POJO做一个总结，POJO在开发中到底是什么？为什么会提出POJO？POJO在开发中体现在哪些地方？这其实是我一直关心的，在一开始接触Java时，其实我对这POJO的概念并不是理解很深，只停留在概念上，随着我对Java的不断深入理解，我从Spring身上看到了POJO的影子，所以想从Spring上浅谈一下我对POJO的理解，内容并不深，这里我并不想专门的谈论Spring，而是从一些基本的使用角度上浅谈POJO，也能进一步理解Spring设计理念的一些体现。</p>
<span id="more"></span>

<h2 id="什么是POJO？"><a href="#什么是POJO？" class="headerlink" title="什么是POJO？"></a>什么是POJO？</h2><blockquote>
<p>POJO，即”Plain Old Java Object”。我们可以认为POJO是一个”纯粹”的Java对象，而什么是”纯粹”的Java对象？就是以Java语言规范为基础设计的对象就是一个POJO。从而进一步我们可以理解POJO是指没有实现相关第三方接口、继承相关的第三方类的Java对象，即非侵入的Java对象。</p>
</blockquote>
<h2 id="为什么会出现POJO？"><a href="#为什么会出现POJO？" class="headerlink" title="为什么会出现POJO？"></a>为什么会出现POJO？</h2><blockquote>
<p>POJO可以从以前的EJB开发模式中谈起，在Spring以前，EJB主导的开发模式中，EJB开发者需要依赖按照J2EE规范实现的J2EE应用服务器，具体实现时需要遵循一系列的接口标准，这样才能够在应用服务器的环境中得到测试和部署（特别是测试环境依赖于对制定规范接口的调用），所以在EJB规范中设计的各种类大都属于侵入式，即，他们会去实现相关的接口、继承相关的父类，他们与业务紧密相连，而不是一个简单的、纯粹的类，而Spring设计者提倡<strong>J2EE without EJB</strong>，正是基于POJO的设计思想，让我们在业务系统中设计一些“纯粹的”类，它们只是符合Java语言规范的简单Java对象，这样脱离以前EJB复杂的开发流程下，我们开发的入门、测试、应用部署都得到了简化。</p>
</blockquote>
<h2 id="最基本的POJO"><a href="#最基本的POJO" class="headerlink" title="最基本的POJO"></a>最基本的POJO</h2><p>比如一个简单的User类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>. id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>. name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述就是一个简单的POJO，它并未与其他业务框架产生耦合，比如实现特定业务框架的接口、继承相关业务类等，它只不过是简单的按照Java语言规范定义了相关的private 属性，并提供基本的<strong>getter、setter</strong>对外暴露接口提供对该对象的基本操作。</p>
<h2 id="POJO的实际应用"><a href="#POJO的实际应用" class="headerlink" title="POJO的实际应用"></a>POJO的实际应用</h2><p>基于上述基本的POJO的设计后，虽然它此时并不能为我们的业务提供支持，但我们现在就可以在此基础上进行不断的扩展，让它不断的适配我们的业务系统，比如现在我们的系统需要相关的身份验证、鉴权，那么我们就可以让该POJO实现Spring Security特有的UserDetail接口，此时它就从一个普通的POJO摇身一变成为了与系统安全相关的业务类。而如果我们不是想做系统安全相关的系统设计，而是打算让它成为数据库用户表的数据承载，那么我们甚至可以不用修改它，让它作为数据库查询、插入相关的数据载体等。此时这两种应用场景的示例都是在POJO基础上进行扩展的，基于POJO简单的特点，使得我们在开发时可以在POJO基础上具有高度的扩展性，完成不同方向的设计，这就是Spring所提倡的POJO开发方式。</p>
<p>另一个更能说明的例子就是SpringMVC，在原本J2EE规范下进行Web开发时，我们往往会根据特定业务设计一种类型的Servlet，而为了支持被Web容器所管理，通常我们会去继承HttpServlet，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooHttpServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">	            <span class="comment">// code </span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">               <span class="comment">// code</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">               <span class="comment">// code</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上述的FooHttpServlet 就不是一个POJO，因为它继承了特定规范的 HttpServlet 抽象类，我们可以认为这个类已经被侵入了，所以它只能用于特定的场合（Web）。</p>
<p>但SpringMVC设计理念中，以DispatcherServlet为核心的MVC模式所设计的Controller，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooController</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methdA</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="comment">// code</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它就是一个POJO，因为它本身没有实现相关的接口、继承相关的类等，而如果在SpringMVC层面，我们要让这个POJO起作用，我们只需要将它通过在XML配置Bean的方式让IOC容器启动时扫描并加入到容器中即可提供服务，这就是Spring所一直倡导的POJO开发模式的具体体现之一，这种方式是相当的简洁的，因为如果它不是一个POJO，比如它还实现了相关接口、继承相关的类，那么我们在使用时还需要了解这些接口规范等，那么开发时也就有了复杂性，而简单的一个POJO，我们只需要停留在这一个层面即可，对比起来POJO的优势就体现出来的。</p>
<p>当然，现在实际开发中，我们并不会完全的按照POJO的设计方式，比如上面的FooController我们很少会专门在XML中配置它，而是通过在上面注解的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span> <span class="comment">//注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methdA</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="comment">// code</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>严格按照POJO的定义来理解，那么它此时就不是一个POJO了，但总的来说，它比起原本J2EE开发模式中使用Servlet 已经相当的简洁的，上述虽然严格上不是一个POJO，但可以认为它是在POJO的基础上进行扩展的，而Spring要做到基于POJO或以POJO为基础进行扩展的开发模式，首先要做的就是在原本特定场合（如Web）的规范下向上抽象，通过建立抽象层使得我们可以只需要在最上层通过设计简单的POJO或基于POJO扩展的对象就能完成应用功能的设计，而基于Spring的相关应用（如MVC、Security）帮助我们完成了中间层复杂的转换，其实现核心就是，将开发中面临的共性问题集中抽象，Spring对抽象层进行实现，从而为开发者提供最小程度的设计成本，也就是设计一个最简单的POJO来完成应用的开发，这就是Spring希望做的。</p>
]]></content>
      
        
        <tags>
            
            <tag> Spring </tag>
            
            <tag> JavaEE </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
